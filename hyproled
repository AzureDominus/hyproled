#!/bin/bash
shift=false; invert=false; monitor=0
fill_color='0.0,0.0,0.0,1.0'

STATE_FILE="/dev/shm/hyproled_shift.state"
SHADER_FILE="/dev/shm/hyproled_shader.glsl"
DT_STATE_FILE="/dev/shm/hyproled_damage_tracking.state"

get_damage_tracking_mode() {
  # hyprctl prints:
  #   int: 2
  #   set: false
  hyprctl --instance 0 getoption debug:damage_tracking 2>/dev/null | awk '/^int:/ { print $2; exit }'
}

set_damage_tracking_mode() {
  hyprctl --instance 0 keyword debug:damage_tracking "$1" >/dev/null 2>&1
}

maybe_enable_damage_workaround() {
  # With full damage tracking (2), Hyprland may leave stale pixels for some
  # transparent / overlay compositions + screen_shader, which shows up as
  # "glitchy" regions until a full redraw happens. Switching to monitor mode (1)
  # forces a full monitor repaint when anything changes, but still allows VFR.
  [[ -f "$DT_STATE_FILE" ]] && return 0

  local cur
  cur="$(get_damage_tracking_mode)"
  [[ -z "$cur" ]] && return 0

  if [[ "$cur" == "2" ]]; then
    echo "$cur" > "$DT_STATE_FILE"
    set_damage_tracking_mode 1
  fi
}

maybe_restore_damage_workaround() {
  [[ -f "$DT_STATE_FILE" ]] || return 0

  local prev cur
  read -r prev < "$DT_STATE_FILE" || prev=""
  rm -f "$DT_STATE_FILE"

  # Only restore if we're still on the mode we set, otherwise assume the user
  # changed it manually and don't fight them.
  cur="$(get_damage_tracking_mode)"
  [[ -z "$prev" ]] && return 0
  [[ "$cur" == "1" ]] && set_damage_tracking_mode "$prev"
}

show_help(){
  cat <<EOF
Usage: $(basename $0) [OPTION]... [off]

Hyprland shader utility to prevent OLED burn in.

version: 0.1.3

Options:
  -a x:y:w:h  The effective area. Useful for bars. [Default: The entire screen]
  -i          Inverts the area. Useful for focus effect of a window or popup.
  -s          Shift lit pixels. Useful to prevent burn in, when called periodically.
  -m ID       Id of your oled monitor (hyprctl monitors). [Default: 0]
  -h          Display this help message.

Argument:
  off         Disable hyproled
EOF
}

if [[ $1 == off ]]; then
  hyprctl --instance 0 keyword decoration:screen_shader ""
  maybe_restore_damage_workaround
  exit 0
fi

while getopts ":a:ism:h" opt; do
  case $opt in
    a) area=$OPTARG ;;
    i) invert=true ;;
    s) shift=true ;;
    m) monitor=$OPTARG ;;
    h) show_help; exit 0 ;;
    *) show_help; exit 1 ;;
  esac
done
shift $((OPTIND-1))

maybe_enable_damage_workaround


# Compute shift offset
if $shift; then
  last_shift=0
  [[ -f $STATE_FILE ]] && read -r last_shift < "$STATE_FILE"
  if (( last_shift == 0 )); then
    shift_offset=1
    echo 1 > "$STATE_FILE"
  else
    shift_offset=0
    echo 0 > "$STATE_FILE"
  fi
else
  shift_offset=0
fi

shader_code="#version 300 es
precision highp float;
in vec2 v_texcoord;
uniform sampler2D tex;
uniform int wl_output;
layout(location = 0) out vec4 fragColor;
void main(){
  vec4 orig = texture(tex, v_texcoord);
  if(wl_output != ${monitor}) { fragColor = orig; return; }
  // Don't use gl_FragCoord here: Hyprland may render the screen_shader only for
  // damaged regions, which can shift the viewport and make gl_FragCoord local.
  // v_texcoord stays stable and maps to the full output texture.
  ivec2 texSize = textureSize(tex, 0);
  vec2 fc = v_texcoord * vec2(texSize);
  ivec2 ip = clamp(ivec2(fc), ivec2(0), texSize - ivec2(1));
  bool even = ((ip.x + ip.y + ${shift_offset}) & 1) == 0;
  vec4 pixel = even ? orig : vec4(${fill_color});
"

if [[ -n $area ]]; then
  if [[ $area =~ ^([0-9]+):([0-9]+):([0-9]+):([0-9]+)$ ]]; then
    read x y w h <<< "${BASH_REMATCH[*]:1:4}"
    shader_code+="  bool inRegion = (fc.x >= ${x}.0 && fc.x <= (${x}.0+${w}.0) && fc.y >= ${y}.0 && fc.y <= (${y}.0+${h}.0));
"
    if $invert; then
      shader_code+="  fragColor = inRegion ? orig : pixel;
"
    else
      shader_code+="  fragColor = inRegion ? pixel : orig;
"
    fi
    shader_code+="}
"
  else
    echo "Invalid area format, use x:y:w:h" >&2; exit 1
  fi
else
  shader_code+="  fragColor = pixel;
}
"
fi

echo "$shader_code" > "$SHADER_FILE"


hyprctl --instance 0 keyword decoration:screen_shader "$SHADER_FILE"
